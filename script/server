#!/usr/bin/env node

var http      = require('http'),
    tilelive  = require('tilelive'),
    mbtiles   = require('mbtiles'),
    minimist  = require('minimist'),
    fs        = require('fs'),
    path      = require('path'),
    url       = require('url')

const argv    = minimist(process.argv.slice(2)),
      port    = argv.port || 4326,
      pattern = /^\/(\d+)\/(\d+)\/(\d+).pbf$/

if(!argv.mbtiles || argv.mbtiles.search(/^mbtiles:\/\//) == -1) {
  return console.log("Usage: " + path.basename(__filename) + ' --mbtiles mbtiles://path/to/tiles')
}

mbtiles.registerProtocols(tilelive)

tilelive.load(argv.mbtiles, function(err, source) {
  if(err) return console.log(err)

  var server = http.createServer(serve)
  server.listen(port, function listen() {
    console.log('Serving tiles on http://127.0.0.1:%s', port)
  })

  function serve(req, res) {
    var uri = url.parse(req.url),
        path = uri.path,
        parts = path.match(pattern)

    if(req.url == '/favicon.ico') return
    if(path.search(pattern) == -1)
      return console.log('Invalid URL format: ' + req.url + ' Use /z/x/y.pbf')

    var z = parts[1],
        x = parts[2],
        y = parts[3]

    console.log('Serving tile %d, %d, %d', z, x, y)

    source.getTile(z, x, y, function(err, tile, headers) {
      if(err) {
        res.writeHead(404, { 'Content-Type': 'text/plain' })
        return res.end(err.message)
      } else {
        headers['Access-Control-Allow-Origin'] = '*'
        headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept'
        res.writeHeader(200, headers)
        res.end(tile)
      }
    })
  }
})
